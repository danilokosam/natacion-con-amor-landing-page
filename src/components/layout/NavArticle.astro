---
const { title } = Astro.props;
---

<div class='max-xl:hidden'>
  <div
    id='nav-content'
    class='sticky top-24 mt-8 mb-20 max-h-[calc(100svh-2.5rem)] w-72 overflow-x-hidden rounded-2xl border border-neutral-100 bg-white px-6 pt-8 pb-12 dark:border-0 dark:bg-transparent scroll-m-24'
  >
    <div class='flex flex-col gap-4 pl-0'>
      <div>
        <h3
          class='text-blacktext/90 text-md font-black tracking-wide uppercase dark:text-zinc-400'
        >
          Table of Contents
        </h3>
      </div>
      <div
        class='flex flex-col gap-2 pr-6 text-neutral-500 dark:text-neutral-300'
      >
        <ul
          id='toc-list'
          class='border-blacktext/20 gap-2 border-l text-base leading-loose dark:border-neutral-500/20'
        >
          <li class='leading-loose'>
            <span class='border-blacktext hover:border-blacktext inline-block border-l pl-4 leading-5 font-bold text-white dark:border-white dark:hover:border-white select-none'>
              
              {title}</span
            >
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>

<script is:inline>
  document.addEventListener('astro:page-load', function () {
    const tocList = document.getElementById('toc-list');
    const content = document.getElementById('content');

    if (!tocList || !content) return;

    // Obtenemos todos los headers
    const headers = content.querySelectorAll('h2, h3');
    let currentUl = tocList;

    // --- 1. Generación del HTML del TOC (Tu lógica original) ---
    headers.forEach((header, index) => {
      if (!header.id) {
        header.id =
          header.textContent?.trim().toLowerCase().replace(/\s+/g, '-') +
          '-' +
          index;
      }

      const li = document.createElement('li');
      const link = document.createElement('a');
      link.href = `#${header.id}`;
      link.textContent = header.textContent?.trim() || header.id;

      // Clases base
      link.classList.add(
        'inline-block',
        'leading-5',
        'hover:text-mint-400',
        'py-2',
        'border-l',
        'border-transparent',
        'dark:hover:border-white',
        'hover:border-blacktext',
      );
      link.classList.add(header.tagName === 'H2' ? 'pl-6' : 'pl-12');

      li.appendChild(link);

      if (header.tagName === 'H2') {
        currentUl = document.createElement('ul');
        currentUl.classList.add(
          'border-neutral-400',
          'dark:hover:border-white',
          'hover:border-blacktext',
          'pl-0',
        );
        const h2Li = document.createElement('li');
        h2Li.appendChild(link);
        h2Li.appendChild(currentUl);
        tocList.appendChild(h2Li);
      } else {
        currentUl.appendChild(li);
      }

      link.addEventListener('click', function (e) {
        e.preventDefault();
        document
          .getElementById(header.id)
          ?.scrollIntoView({ behavior: 'smooth', block: 'start' });
      });
    });

    // --- 2. Lógica del Observer Corregida ---

    // Usamos un Set para guardar qué headers están visibles actualmente
    const visibleHeaders = new Set();

    const observer = new IntersectionObserver(
      (entries) => {
        // A. Actualizamos el estado de visibilidad
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            visibleHeaders.add(entry.target.id);
          } else {
            visibleHeaders.delete(entry.target.id);
          }
        });

        // B. Determinamos cuál es el header "activo"
        // Recorremos los headers en orden del DOM. El primero que esté en nuestro Set 'visibleHeaders' es el ganador.
        let activeId = null;
        for (const header of headers) {
          if (visibleHeaders.has(header.id)) {
            activeId = header.id;
            break; // ¡Encontramos el más alto! Dejamos de buscar.
          }
        }

        // Si no hay ninguno visible (ej. estamos en medio de un párrafo largo),
        // opcionalmente podrías no hacer nada para mantener el último activo.
        if (activeId) {
          // C. Actualizamos las clases (Solo una vez)
          document.querySelectorAll('#toc-list a').forEach((el) => {
            // Quitamos estilos de activo
            el.classList.remove(
              'font-semibold',
              'dark:text-mint-300',
              'text-blacktext',
              'dark:border-white',
              'border-blacktext',
              'dark:text-mint-300!',
              'text-blacktext!',
              'dark:border-white!',
              'border-blacktext!',
            );
            // Añadimos estilos inactivos
            el.classList.add('dark:text-neutral-300', 'text-neutral-500');
          });

          const activeLink = document.querySelector(`a[href="#${activeId}"]`);
          if (activeLink) {
            // Quitamos estilos inactivos
            activeLink.classList.remove(
              'dark:text-neutral-300',
              'text-neutral-500',
            );
            // Añadimos estilos de activo
            activeLink.classList.add(
              'font-semibold',
              'dark:text-mint-300!',
              'text-blacktext!',
              'border-l',
              'dark:border-white!',
              'border-blacktext!',
            );
          }
        }
      },
      {
        // AJUSTE CLAVE:
        // Top: -100px (o aprox la altura de tu navbar) para que detecte el titulo apenas llegue arriba.
        // Bottom: -60% (mantiene el foco en la mitad superior de la pantalla).
        rootMargin: '-100px 0px -60% 0px',
        threshold: 0, // Se activa apenas 1 pixel toca la zona
      },
    );

    headers.forEach((header) => observer.observe(header));
  });
</script>
